Here is the **cleanest, production-ready way** to implement **Pagination + Search** in **Next.js 16 (App Router)** with **MySQL + Prisma**.

This works for:

âœ… Server Components
âœ… API Routes
âœ… Client Components
âœ… Large datasets
âœ… Search + Pagination combined
------------------------------

# ğŸ§± **Database Example (Posts Table)**

```prisma
model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  createdAt DateTime @default(now())
}
```

---

# ğŸš€ **1. API Route: Pagination + Search**

`app/api/posts/route.ts`

```ts
import { PrismaClient } from "@prisma/client";
const prisma = new PrismaClient();

export async function GET(req: Request) {
  const { search, page, limit } = Object.fromEntries(
    new URL(req.url).searchParams
  );

  const pageNum = Number(page) || 1;
  const limitNum = Number(limit) || 10;
  const skip = (pageNum - 1) * limitNum;

  const where = search
    ? {
        OR: [
          { title: { contains: search, mode: "insensitive" } },
          { content: { contains: search, mode: "insensitive" } },
        ],
      }
    : {};

  const [data, total] = await Promise.all([
    prisma.post.findMany({
      where,
      skip,
      take: limitNum,
      orderBy: { createdAt: "desc" },
    }),
    prisma.post.count({ where }),
  ]);

  return Response.json({
    data,
    total,
    page: pageNum,
    lastPage: Math.ceil(total / limitNum),
  });
}
```

ğŸ” Features:

* Search by title + content
* Pagination using `skip` + `take`
* Returns total pages

---

# ğŸ¯ **2. SERVER Component Example (SSR Pagination + Search)**

`app/posts/page.tsx`

```tsx
import Link from "next/link";

async function getPosts(search: string, page: number) {
  const res = await fetch(
    `${process.env.NEXT_PUBLIC_URL}/api/posts?search=${search}&page=${page}&limit=5`,
    { cache: "no-store" }
  );
  return res.json();
}

export default async function PostsPage({ searchParams }) {
  const search = searchParams.search || "";
  const page = Number(searchParams.page) || 1;

  const { data, lastPage } = await getPosts(search, page);

  return (
    <div className="p-4">
      <form className="mb-4">
        <input
          type="text"
          name="search"
          defaultValue={search}
          className="border p-2"
          placeholder="Search..."
        />
      </form>

      {data.map((post) => (
        <div key={post.id} className="border p-2 mb-3">
          <h2>{post.title}</h2>
        </div>
      ))}

      {/* Pagination */}
      <div className="flex gap-3 mt-4">
        {page > 1 && (
          <Link href={`?search=${search}&page=${page - 1}`}>â¬… Previous</Link>
        )}

        {page < lastPage && (
          <Link href={`?search=${search}&page=${page + 1}`}>Next â¡</Link>
        )}
      </div>
    </div>
  );
}
```

âœ” Fully SSR
âœ” URL-based pagination
âœ” Search + page saved in URL
----------------------------

# âš›ï¸ **3. CLIENT Component Example (Instant Search + Pagination)**

`app/posts/client-page/page.tsx`

```tsx
"use client";

import { useEffect, useState } from "react";

export default function ClientPosts() {
  const [posts, setPosts] = useState([]);
  const [search, setSearch] = useState("");
  const [page, setPage] = useState(1);
  const [lastPage, setLastPage] = useState(1);

  const getData = async () => {
    const res = await fetch(`/api/posts?search=${search}&page=${page}&limit=5`);
    const json = await res.json();
    setPosts(json.data);
    setLastPage(json.lastPage);
  };

  useEffect(() => {
    getData();
  }, [search, page]);

  return (
    <div className="p-4">
      <input
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder="search..."
        className="border p-2 mb-4"
      />

      {posts.map((post) => (
        <div key={post.id} className="border p-2 mb-3">
          <h3>{post.title}</h3>
        </div>
      ))}

      <div className="flex gap-3 mt-4">
        {page > 1 && <button onClick={() => setPage(page - 1)}>Previous</button>}
        {page < lastPage && <button onClick={() => setPage(page + 1)}>Next</button>}
      </div>
    </div>
  );
}
```

âœ” Instant type search
âœ” Client-side pagination

---

# ğŸ§ª BONUS: RAW SQL Pagination + Search

If you want SQL instead of Prisma functions:

```ts
const data = await prisma.$queryRaw`
  SELECT * FROM posts
  WHERE title LIKE ${'%' + search + '%'}
  ORDER BY id DESC
  LIMIT ${limit}
  OFFSET ${skip}
`;
```

---

# ğŸ‰ Summary

| Feature            | Prisma Code               | Works In            |
| ------------------ | ------------------------- | ------------------- |
| Pagination         | `skip`, `take`            | API, Server, Client |
| Search             | `contains`, `insensitive` | Everywhere          |
| SSR Pagination     | Works                     | Server Component    |
| Client Pagination  | Works                     | useEffect           |
| RAW SQL Pagination | Works                     | MySQL               |

---

# If you want

I can generate:

### âœ” Pagination component (Bootstrap / Tailwind)

### âœ” Search with debounce

### âœ” Filtering + ordering (like Laravel Datatable)

### âœ” Full CRUD with search & pagination

Just say: **â€œgive me full pagination system UI + APIâ€**
