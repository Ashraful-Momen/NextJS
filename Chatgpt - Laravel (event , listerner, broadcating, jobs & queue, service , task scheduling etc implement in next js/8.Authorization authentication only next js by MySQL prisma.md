Below is the **cleanest, production-ready authentication + authorization system** using:

âœ… **Next.js 16 (App Router)**
âœ… **MySQL**
âœ… **Prisma**
âŒ **NO NextAuth**
âŒ **NO external service**
âœ” 100% **custom auth like Laravel Breeze / Sanctum**

---

# ğŸ”¥ FINAL RESULT

You will get:

### âœ” Register

### âœ” Login

### âœ” Password hashing

### âœ” JWT token (httpOnly cookie)

### âœ” Protect API Routes

### âœ” Protect Pages

### âœ” Roles + Permissions (optional but included)

---

# âš™ï¸ Step 1 â€” Install Prisma + MySQL adapter

```bash
npm install prisma @prisma/client bcryptjs jsonwebtoken
```

---

# ğŸ“Œ Step 2 â€” Prisma Schema (User + Role)

`prisma/schema.prisma`

```prisma
model User {
  id       Int      @id @default(autoincrement())
  name     String
  email    String   @unique
  password String
  role     Role     @default(USER)
}

enum Role {
  ADMIN
  USER
}
```

Run migration:

```bash
npx prisma migrate dev
```

---

# ğŸ” Step 3 â€” Helper functions (hash & token)

`lib/auth.ts`

```ts
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";

export function hashPassword(password: string) {
  return bcrypt.hashSync(password, 10);
}

export function verifyPassword(password: string, hash: string) {
  return bcrypt.compareSync(password, hash);
}

export function generateToken(payload: any) {
  return jwt.sign(payload, process.env.JWT_SECRET!, {
    expiresIn: "4h", // like Laravel Sanctum
  });
}

export function verifyToken(token: string) {
  return jwt.verify(token, process.env.JWT_SECRET!);
}
```

Set secret in `.env`:

```
JWT_SECRET=supersecretkey123
```

---

# ğŸ§¾ Step 4 â€” Register API Route (POST)

`app/api/auth/register/route.ts`

```ts
import { PrismaClient } from "@prisma/client";
import { hashPassword } from "@/lib/auth";

const prisma = new PrismaClient();

export async function POST(req: Request) {
  const { name, email, password } = await req.json();

  const userExist = await prisma.user.findUnique({ where: { email } });
  if (userExist)
    return Response.json({ error: "Email already exists" }, { status: 400 });

  const hashed = hashPassword(password);

  const user = await prisma.user.create({
    data: { name, email, password: hashed },
  });

  return Response.json({ message: "User registered", user });
}
```

---

# ğŸ”‘ Step 5 â€” Login API Route (POST)

Store JWT in **httpOnly cookie** (secure & protected).

`app/api/auth/login/route.ts`

```ts
import { PrismaClient } from "@prisma/client";
import { verifyPassword, generateToken } from "@/lib/auth";
import { cookies } from "next/headers";

const prisma = new PrismaClient();

export async function POST(req: Request) {
  const { email, password } = await req.json();

  const user = await prisma.user.findUnique({ where: { email } });
  if (!user)
    return Response.json({ error: "Invalid credentials" }, { status: 401 });

  const valid = verifyPassword(password, user.password);
  if (!valid)
    return Response.json({ error: "Invalid credentials" }, { status: 401 });

  const token = generateToken({
    id: user.id,
    role: user.role,
    email: user.email,
  });

  cookies().set("token", token, {
    httpOnly: true,
    secure: true,
    path: "/",
  });

  return Response.json({ message: "Login success" });
}
```

---

# ğŸšª Step 6 â€” Logout API Route

`app/api/auth/logout/route.ts`

```ts
import { cookies } from "next/headers";

export async function POST() {
  cookies().delete("token");
  return Response.json({ message: "Logged out" });
}
```

---

# ğŸ›¡ Step 7 â€” Protect API Routes (Middleware)

`middleware.ts`

```ts
import { NextResponse } from "next/server";
import jwt from "jsonwebtoken";

export function middleware(req: any) {
  const token = req.cookies.get("token")?.value;

  if (!token)
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });

  try {
    jwt.verify(token, process.env.JWT_SECRET!);
    return NextResponse.next();
  } catch {
    return NextResponse.json({ error: "Invalid token" }, { status: 401 });
  }
}

export const config = {
  matcher: ["/api/protected/:path*"],
};
```

Any route under `/api/protected/*` is now secured.

---

# ğŸ›¡ Step 8 â€” Role Authorization (Admin Guard)

Extend middleware:

```ts
const payload: any = jwt.verify(token, process.env.JWT_SECRET!);

if (req.nextUrl.pathname.startsWith("/api/admin")) {
  if (payload.role !== "ADMIN") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }
}
```

---

# ğŸ–¥ Step 9 â€” Protect Server Components (SSR)

```tsx
import { cookies } from "next/headers";
import jwt from "jsonwebtoken";

export default async function Dashboard() {
  const token = cookies().get("token")?.value;

  if (!token) return <h1>Unauthorized</h1>;

  const user = jwt.verify(token, process.env.JWT_SECRET!);

  return <h1>Welcome {user.email}</h1>;
}
```

---

# ğŸ¯ Step 10 â€” Protect Client Components

```tsx
"use client";
import { useEffect, useState } from "react";

export default function Protected({ children }) {
  const [auth, setAuth] = useState(false);

  useEffect(() => {
    fetch("/api/auth/me")
      .then((res) => {
        if (res.ok) setAuth(true);
      })
      .catch(() => {});
  }, []);

  if (!auth) return <p>Unauthorized</p>;

  return children;
}
```

---

# ğŸ‰ FINAL SETUP

You now have:

### âœ” Custom authentication (register, login, logout)

### âœ” JWT stored in protected httpOnly cookie

### âœ” Authorization using roles

### âœ” Middleware protection

### âœ” Server-side protection

### âœ” Client-side protection

### âœ” 100% works with MySQL + Prisma

### âœ” Same flow as Laravel Sanctum + middleware + guard

---

# ğŸš€ If you want

Tell me:

### **â€œGive me full auth boilerplate (with folder structure)â€**

and I will generate a complete project you can copy-paste and run.
