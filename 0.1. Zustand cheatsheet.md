Here is the **COMPLETE ZUSTAND CHEATSHEET** â€” clean, simple, and covers **EVERYTHING** you need to use Zustand like a pro.
(From beginner â†’ advanced â†’ production)

---

# ğŸš€ **ZUSTAND COMPLETE CHEATSHEET (2025)**

(Everything you will ever need)

---

# 1ï¸âƒ£ **Installation**

```
npm install zustand
```

---

# 2ï¸âƒ£ **Basic Store (Redux-like)**

```js
import { create } from "zustand";

export const useStore = create((set) => ({
  count: 0,
  increment: () => set((s) => ({ count: s.count + 1 })),
}));
```

Use:

```js
const { count, increment } = useStore();
```

---

# 3ï¸âƒ£ **Store with Payload**

```js
add: (value) => set((s) => ({ count: s.count + value })),
```

Use:

```js
add(5);
```

---

# 4ï¸âƒ£ **Multiple State Values**

```js
export const useStore = create((set) => ({
  count: 0,
  name: "John",
  setName: (name) => set({ name }),
}));
```

---

# 5ï¸âƒ£ **Reading Only Parts of Store (Recommended for Performance)**

```js
const count = useStore((s) => s.count);
```

---

# 6ï¸âƒ£ **Middleware: DevTools + Logger**

```
npm install zustand/middleware
```

```js
import { create } from "zustand";
import { devtools, logger } from "zustand/middleware";

export const useStore = create(
  logger(
    devtools((set) => ({
      count: 0,
      inc: () => set((s) => ({ count: s.count + 1 })),
    }))
  )
);
```

---

# 7ï¸âƒ£ **Persist Store (localStorage / sessionStorage)**

Great for dark mode, cart, auth tokens.

```js
import { create } from "zustand";
import { persist } from "zustand/middleware";

export const useStore = create(
  persist(
    (set) => ({
      count: 0,
      inc: () => set((s) => ({ count: s.count + 1 })),
    }),
    {
      name: "my-app-storage", // key
    }
  )
);
```

---

# 8ï¸âƒ£ **Immer Support (Redux Toolkit style immutability)**

```
npm install immer
```

```js
import { create } from "zustand";
import { immer } from "zustand/middleware/immer";

export const useStore = create(
  immer((set) => ({
    user: { name: "abc", age: 20 },

    updateUser: (data) =>
      set((s) => {
        Object.assign(s.user, data);
      }),
  }))
);
```

---

# 9ï¸âƒ£ **Splitting Store into Slices (Recommended for big apps)**

Structure:

```
/store/createUserSlice.js
/store/createProductSlice.js
/store/index.js
```

### createUserSlice.js

```js
export const createUserSlice = (set) => ({
  user: null,
  setUser: (user) => set({ user }),
});
```

### createProductSlice.js

```js
export const createProductSlice = (set) => ({
  products: [],
  addProduct: (p) =>
    set((s) => ({ products: [...s.products, p] })),
});
```

### index.js

```js
import { create } from "zustand";
import { createUserSlice } from "./createUserSlice";
import { createProductSlice } from "./createProductSlice";

export const useStore = create((set) => ({
  ...createUserSlice(set),
  ...createProductSlice(set),
}));
```

Use:

```js
const user = useStore((s) => s.user);
const addProduct = useStore((s) => s.addProduct);
```

---

# ğŸ”Ÿ **Async Actions (API calls)**

```js
export const useStore = create((set) => ({
  loading: false,
  user: null,

  fetchUser: async () => {
    set({ loading: true });
    const res = await fetch("/api/user");
    const data = await res.json();
    set({ user: data, loading: false });
  },
}));
```

Use:

```js
useStore.getState().fetchUser();
```

---

# 1ï¸âƒ£1ï¸âƒ£ **Reset Store**

```js
reset: () => set({ count: 0, name: "" })
```

Or reset whole store:

```js
useStore.setState(initialState);
```

---

# 1ï¸âƒ£2ï¸âƒ£ **Set State Outside Components**

Useful for server actions or event listeners.

```js
useStore.setState({ count: 100 });
```

---

# 1ï¸âƒ£3ï¸âƒ£ **Subscribe to store changes (global listeners)**

```js
useStore.subscribe((state) => {
  console.log("Changed:", state.count);
});
```

---

# 1ï¸âƒ£4ï¸âƒ£ **Selectors for Better Performance**

```js
const count = useStore((state) => state.count);
```

With multiple:

```js
const { count, name } = useStore((s) => ({
  count: s.count,
  name: s.name,
}));
```

---

# 1ï¸âƒ£5ï¸âƒ£ **Shallow Compare (prevent re-render)**

```
import { shallow } from "zustand/shallow";
```

```js
const { count, name } = useStore(
  (s) => ({ count: s.count, name: s.name }),
  shallow
);
```

---

# 1ï¸âƒ£6ï¸âƒ£ **Zustand with Server Components (Next.js)**

If using Zustand in Next.js:

Add:

```jsx
"use client";
```

Zustand is always client-side.

If you need it in Server Component â†’ use:

```js
const state = useStore.getState();
```

---

# 1ï¸âƒ£7ï¸âƒ£ **Hydration Fix in Next.js**

For persisted stores:

```js
const hydrated = useStore((s) => s._hasHydrated);

if (!hydrated) return null;
```

---

# 1ï¸âƒ£8ï¸âƒ£ **Combine Zustand + React Query (Best Practice)**

Zustand: UI state
React Query: Server/API state

Example:

```js
const { data } = useQuery(["users"], fetchUsers);
const { filter, setFilter } = useFilterStore();
```

---

# 1ï¸âƒ£9ï¸âƒ£ **Zustand SSR (rarely needed)**

Zustand = client-side
But SSR possible with special patterns (not recommended unless necessary).

---

# 2ï¸âƒ£0ï¸âƒ£ **Full Production Patterns**

* Slices
* Immer
* Persist
* Devtools
* Shallow compare
* Selectors
* Outside actions (`getState()`)
* React Query for API
* Server Actions for mutations

---

# ğŸ‰ **This cheatsheet covers everything:**

âœ” State
âœ” Actions
âœ” Payload
âœ” Async
âœ” Persist
âœ” Immer
âœ” Slices
âœ” Middleware
âœ” Subscriptions
âœ” Next.js usage
âœ” Hydration
âœ” React Query combo
âœ” Production patterns

---

# ğŸš€ Want more?

I can also give you:

### ğŸ”¥ A complete â€œLaravel-style Next.js Appâ€ using:

* Next.js
* Prisma
* Zustand
* React Query
* Server Actions
* Redis
* Realtime WebSockets

Just tell me â€œYES build itâ€.
